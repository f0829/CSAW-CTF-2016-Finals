#!/usr/bin/env python

from pwn import *
import z3
import sys
from time import time, sleep

class Solver:
    def __init__(self):
        self.solver = z3.Solver()
        self.check = self.solver.check
        self.model = self.solver.model
        self.seed = z3.BitVec("seed", 32)
        self.current = self.seed
        self.states = 1
        self.solver.add(self.seed != 0)
        if self.check() != z3.sat:
            raise RuntimeError("UNSAT")

    def get_seed(self):
        return self.model()[self.seed].as_long()

    def advance(self, n, i, first):
        # add all intermediate states for each step
        for x in range(0, n):
            p1 = z3.BitVec("part" + str(self.states), 32)
            p2 = z3.BitVec("part" + str(self.states+1), 32)
            p3 = z3.BitVec("part" + str(self.states+2), 32)
            self.solver.add(p1 == self.current ^ (self.current << 13))
            self.solver.add(p2 == p1 ^ z3.LShR(p1, 14))
            self.solver.add(p3 == p2 ^ (p2 << 15))
            self.states += 3
            self.current = p3

        # if this is the "leak" at the beginning, add it directly
        if first > 0:
            self.solver.add((p3 & 0xFFFF) == first)
        # if this isn't, we've stopped on a stable state and should add constraints
        else:
            """
            unsigned char n = (x & (0xFF << i)) >> i;
            if (n != 0 && n == (n & -n)) {
            """
            n = z3.LShR(self.current & (0xFF << i), i)
            self.solver.add(n != 0)
            #self.solver.add(z3.LShR(self.current & (0xFF << i), i) != 0)
            self.solver.add(n == n & -n)
            #self.solver.add(z3.LShR(self.current & (0xFF << i), i) == (z3.LShR(self.current & (0xFF << i), i) & z3.LShR((-self.current) & (0xFF << i), i)))

        # update our guess if we're still SAT
        if self.check() != z3.sat:
            raise RuntimeError("UNSAT")
        else:
            print "NEW GUESS: %d" % self.get_seed()

    def guess(self, idx):
        g = bin(self.model()[self.current].as_long())[-8-idx:][:8]
        print g
        if (g[0] == "1" and g[1] == "0" and g[2] == "0" and g[3] == "0" and
            g[4] == "0" and g[5] == "0" and g[6] == "0" and g[7] == "0"):
            return "8"
        elif (g[0] == "0" and g[1] == "1" and g[2] == "0" and g[3] == "0" and
            g[4] == "0" and g[5] == "0" and g[6] == "0" and g[7] == "0"):
            return "7"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "1" and g[3] == "0" and
            g[4] == "0" and g[5] == "0" and g[6] == "0" and g[7] == "0"):
            return "6"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "0" and g[3] == "1" and
            g[4] == "0" and g[5] == "0" and g[6] == "0" and g[7] == "0"):
            return "5"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "0" and g[3] == "0" and
            g[4] == "1" and g[5] == "0" and g[6] == "0" and g[7] == "0"):
            return "4"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "0" and g[3] == "0" and
            g[4] == "0" and g[5] == "1" and g[6] == "0" and g[7] == "0"):
            return "3"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "0" and g[3] == "0" and
            g[4] == "0" and g[5] == "0" and g[6] == "1" and g[7] == "0"):
            return "2"
        elif (g[0] == "0" and g[1] == "0" and g[2] == "0" and g[3] == "0" and
            g[4] == "0" and g[5] == "0" and g[6] == "0" and g[7] == "1"):
            return "1"
        else:
            raise ValueError("Ambiguous guess")

    def wrong(self, pos):
        self.solver.add(self.seed != self.model()[self.seed].as_long())
        #self.solver.add(self.current & (1 << pos) == 0)
        if self.check() != z3.sat:
            raise RuntimeError("UNSAT")

    def right(self, pos):
        #self.solver.add(self.current & (1 << pos) == (1 << pos))
        #if self.check() != z3.sat:
        #    raise RuntimeError("UNSAT")
        pass

def get_msg(s):
    h = s.recv(2)
    m = s.recv(u8(h[1]))
    return h + m

# let's play a game
if __name__ == "__main__":
    xorshift = Solver()
    start = 0
    cash = 0
    games = 0
    shuffles = 0
    rounds = 0
    streak = 0
    wins = 0
    winrate = 0.0

    # connect to service
    #s = process("./thimblerig")
    s = remote("pwn.chal.csaw.io", 1340)

    # get debug message
    #s.recvline()
    #seed = s.recvline().strip().split()[-1]
    #print "seed: %d" % int(seed)
    #flag = s.recvline()
    #print flag

    # perform handshake
    m = get_msg(s)
    leak = u16(m[2:])
    xorshift.advance(1, 0, leak)
    print "leak: %d" % leak
    s.send("\x01%s" % m[1:])
    get_msg(s)

    while True:
        # record start time
        start = time()

        if winrate >= 0.90 and games >= 20:
            s.send("\xC0\xFF" + "A" * 0xFF)
            sleep(0.5)
            print s.recv()

        # place our bet
        if streak < 5:
            s.send("\x10\x011")
            print "paid: 1"
            cash -= 1
        elif cash/4 > 25:
            s.send("\x10\x0225")
            print "paid: 25"
            cash -= 25
        else:
            s.send("\x10\x0210")
            print "paid: 10"
            cash -= 10

        # let him shuffle
        s.send("\x11\x00")
        sleep(0.5)
        msg = s.recv().strip().split("\x80")  # debug
        print msg[0]
        sleep(0.5)
        print repr(msg[1])
        if msg[1][1:].split()[0] == "Time":
            shuffles = int(msg[1].split()[8])
        elif msg[1][1:].split()[0] == "Eh,":
            shuffles = int(msg[1].split()[3])
        else:
            shuffles = 1
        print repr(msg[2])
        if msg[2][1:].split()[0] == "No":
            idx = 0
        else:
            idx = int(msg[2][1:].split()[4][0])
        print "step: %d.%d" % (shuffles, idx)
        xorshift.advance(shuffles, idx, -1)
        rounds += shuffles

        # make our choice
        guess = xorshift.guess(idx)
        s.send("\x12\x01%s" % guess)
        msg = s.recv()
        print msg
        if msg[2:5] == "You":
            print ">>>>> CORRECT <<<<<"
            if streak < 5:
                cash += 2
            else:
                cash += cash/2
            streak += 1
            wins += 1
            xorshift.right(int(guess[0])-1)
        else:
            print "<<<<< WRONG >>>>>"
            streak = 0
            xorshift.wrong(int(guess[0])-1)

        games += 1
        print "time: %f" % (time() - start)
        winrate = wins / float(games)
        print "WINRATE: %f (%d/%d)" % (winrate, wins, games)
